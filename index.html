<!DOCTYPE html>
<html lang="ar">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ø§Ø®ØªØ¨Ø§Ø± ØªØªØ¨Ù‘Ø¹ Ø§Ù„Ù…Ø³Ø§Ø± - MoCA</title>
  <style>
    body { text-align: center; font-family: Arial; background: #f5f5f5; }
    canvas { border: 1px solid #000; touch-action: none; background-color: white; }
    button { margin: 5px; padding: 8px 15px; font-size: 16px; cursor: pointer; }
  </style>
</head>
<body>

<h2>Ø§Ø®ØªØ¨Ø§Ø± ØªØªØ¨Ù‘Ø¹ Ø§Ù„Ù…Ø³Ø§Ø± - MoCA</h2>
<canvas id="drawCanvas"></canvas><br>
<button onclick="resetCanvas()">ğŸ”„ Ø¥Ø¹Ø§Ø¯Ø©</button>
<button onclick="downloadImage()">ğŸ“· Ø­ÙØ¸ Ø§Ù„Ø®Ø· ÙÙ‚Ø·</button>
<button onclick="downloadData()">ğŸ“„ Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª (Resampled)</button>

<script>
let canvas = document.getElementById('drawCanvas');
let ctx = canvas.getContext('2d');

let bgImage = new Image();
bgImage.src = "moca.png";

let screenWidth = window.innerWidth;
let screenHeight = window.innerHeight;
let canvasWidth, canvasHeight;

function resizeCanvas() {
    let ratio = bgImage.width / bgImage.height || (4/3);
    let maxWidth = screenWidth * 0.95;
    let width = maxWidth;
    let height = width / ratio;
    if (height > screenHeight * 0.7) {
        height = screenHeight * 0.7;
        width = height * ratio;
    }
    canvas.width = width;
    canvas.height = height;
    canvasWidth = width;
    canvasHeight = height;
    drawBackground();
}

function drawBackground() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(bgImage, 0, 0, canvas.width, canvas.height);
}

bgImage.onload = resizeCanvas;
window.addEventListener('resize', resizeCanvas);

let isDrawing = false;
let startTime = null;
let points = [];
let lastPoint = null;

// Ø¯Ø§Ù„Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø§Ù„Ù†Ø³Ø¨ÙŠØ©
function getCoords(evt) {
    let rect = canvas.getBoundingClientRect();
    let x = evt.clientX - rect.left;
    let y = evt.clientY - rect.top;
    let nx = x / canvas.width;
    let ny = y / canvas.height;
    return { x, y, nx, ny };
}

function startDraw(evt) {
    isDrawing = true;
    let coords = getCoords(evt);
    lastPoint = coords;
    if (!startTime) startTime = Date.now();
}

function draw(evt) {
    let coords = getCoords(evt);
    let t = (Date.now() - startTime) / 1000;

    if (isDrawing) {
        // Ø±Ø³Ù… Ø§Ù„Ø®Ø·
        ctx.beginPath();
        ctx.moveTo(lastPoint.x, lastPoint.y);
        ctx.lineTo(coords.x, coords.y);
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.closePath();

        lastPoint = coords;
    }

    // ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù†Ù‚Ø·Ø© (Ø¥Ø°Ø§ Ø±Ø§ÙØ¹ Ø§ÙŠØ¯Ù‡ØŒ lastPoint ØªØªÙƒØ±Ø±)
    points.push({
        x: lastPoint.x,
        y: lastPoint.y,
        nx: lastPoint.nx,
        ny: lastPoint.ny,
        t: t
    });
}

function endDraw() {
    isDrawing = false;
}

function resetCanvas() {
    drawBackground();
    points = [];
    startTime = null;
    lastPoint = null;
}

// Ø£Ø­Ø¯Ø§Ø« Ø§Ù„Ù…Ø§ÙˆØ³
canvas.addEventListener('mousedown', startDraw);
canvas.addEventListener('mousemove', draw);
canvas.addEventListener('mouseup', endDraw);

// Ø£Ø­Ø¯Ø§Ø« Ø§Ù„Ù„Ù…Ø³
canvas.addEventListener('touchstart', e => startDraw(e.touches[0]));
canvas.addEventListener('touchmove', e => {
    draw(e.touches[0]);
    e.preventDefault();
});
canvas.addEventListener('touchend', endDraw);

// Resampling Ù…ÙˆØ­Ø¯ (uniform time series)
function resample(points, step = 0.05) {
    if (points.length < 1) return [];
    let resampled = [];
    let targetT = 0.0;
    let i = 0;
    let lastP = points[0];

    while (targetT <= points[points.length - 1].t) {
        // ØªÙ‚Ø¯Ù‘Ù… Ù„Ù„Ø¥Ø·Ø§Ø± Ø§Ù„ØµØ­ÙŠØ­
        while (i < points.length - 1 && points[i + 1].t < targetT) {
            i++;
            lastP = points[i];
        }

        resampled.push({
            x: lastP.x,
            y: lastP.y,
            nx: lastP.nx,
            ny: lastP.ny,
            t: parseFloat(targetT.toFixed(3))
        });

        targetT += step;
    }

    return resampled;
}

// Ø­ÙØ¸ ØµÙˆØ±Ø© Ø§Ù„Ø®Ø· ÙÙ‚Ø·
function downloadImage() {
    let tempCanvas = document.createElement('canvas');
    tempCanvas.width = canvas.width;
    tempCanvas.height = canvas.height;
    let tempCtx = tempCanvas.getContext('2d');

    tempCtx.lineWidth = 2;
    tempCtx.strokeStyle = 'black';
    tempCtx.beginPath();

    for (let i = 0; i < points.length; i++) {
        let p = points[i];
        if (i === 0) tempCtx.moveTo(p.x, p.y);
        else tempCtx.lineTo(p.x, p.y);
    }
    tempCtx.stroke();

    let link = document.createElement('a');
    link.download = `drawing_${Date.now()}.png`;
    link.href = tempCanvas.toDataURL("image/png");
    link.click();
}

// Ø­ÙØ¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø¹Ø¯ resampling
function downloadData() {
    let resampledPoints = resample(points, 0.05);
    let data = {
        screenWidth,
        screenHeight,
        canvasWidth,
        canvasHeight,
        points: resampledPoints
    };
    let blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
    let link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `trial_${Date.now()}_data.json`;
    link.click();
}
</script>
</body>
</html>
